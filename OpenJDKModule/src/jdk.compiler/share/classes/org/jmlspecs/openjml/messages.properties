## This file is part of the OpenJML project. Author: David R. Cok

## All keys here must start with compiler.err or compiler.warn, at least until
## we figure out how to have more than one Diagnostic generator
## Also make sure that all keys have 'jml' or 'esc' or 'rac' etc. in them so that they can be distinguished
## from regular java error messages

### BE CAREFUL NOT TO INTRODUCE WHITE SPACE AT THE END OF MESSAGES.
### THAT WHITE SPACE IS PART OF THE ERROR MESSAGE AND CAN BE HARD TO SPOT WHEN
### ERROR MESSAGES DO NOT MATCH IN TESTS.

### The fully-qualified name of this file is used within the source (org.jmlspecs.openjml.Utils)

## Untranslated messages
compiler.err.jml.message={0}
compiler.warn.jml.message={0}
compiler.note.jml.message={0}
# The following is used to generate messages containing only location information
compiler.note.empty=

## Configuration errors
compiler.misc.fatal.err.no.org.jmlspecs.lang=\
    Fatal Error: Unable to find package org.jmlspecs.lang

## Command-line errors
compiler.err.jml.bad.command=\
    Invalid parameter to the -command option: {0}
compiler.err.jml.unimplemented.command=\
    Unimplemented parameter to the -command option: {0}
compiler.err.jml.extension.failed=\
    Failed to load extension {0}: {1}
    
## Scanner errors
compiler.err.jml.bad.backslash.token=\
	This backslash token is unknown: {0}
compiler.err.jml.extraneous.backslash=\
	A backslash in a JML comment expects to be followed by a valid identifier
compiler.err.jml.unexpected.at.symbols=\
	These @ symbols are illegal here
compiler.err.jml.at.and.star.but.no.slash=\
	A sequence of @ symbols followed by a * is expected to be followed by a / to end the JML comment
compiler.err.jml.must.be.boolean=\
	An {0} statement must have a boolean argument, rather than type {1}
compiler.warn.jml.line.annotation.with.no.semicolon=\
	A line annotation should end with a semicolon
compiler.err.jml.bad.line.annotation=\
	Expected an identifier here in the line annotation
compiler.err.jml.no.such.extension=\
	No ExpressionExtension found for expression token {0}
compiler.err.jml.failure.to.create.ExpressionExtension=\
    System failure: failed to create an ExpressionExtension instance for token {0}
compiler.err.jml.failure.to.create.JmlExtension=\
    System failure: failed to create an Extension instance for token {0}
compiler.err.jml.unclosed.informal.expression=\
	The informal expression is not closed
compiler.warn.jml.deprecated.conditional.annotation=\
    The //+@ and //-@ annotation styles are deprecated - use keys instead
	
## Parser errors
compiler.err.jml.refines.missing.semicolon=\
	A refines statement needs to be ended by a semicolon
compiler.err.jml.no.args.allowed=\
	A {0} expression does not take an argument list
compiler.err.jml.args.required=\
	A {0} expression must have an argument list
compiler.err.jml.no.typeargs.allowed=\
	A {0} expression may not have type arguments
compiler.err.jml.invalid.expression.or.missing.semi=\
	The expression is invalid or not terminated by a semicolon
compiler.err.jml.bad.represents.token=\
	A represents clause must have a = or \\such_that after the identifier
compiler.err.jml.use.nothing.assignable=\
	Use \\nothing to denote an empty list of locations in an assignable clause
compiler.err.jml.refines.missing.string=\
	A refines declaration must contain a string literal
compiler.err.jml.refines.before.imports=\
	Refines declarations must precede all import declarations and follow any package declaration
compiler.err.jml.empty.specification.case=\
	The specification case near here is empty, which is not permitted
compiler.err.jml.bad.token.in.jml=\
	This token is not expected at this position within a JML annotation: {0}
compiler.err.jml.bad.type.expression=\
	The type or expression near here is invalid (or not implemented): {0}
compiler.err.jml.invalid.spec.group.end=\
	Invalid clause or missing end of specification group token ( |} )
compiler.err.jml.expected.decl.or.jml=\
	Expected a declaration or a JML construct inside the JML annotation here
compiler.warn.jml.misplaced.code=\
	This code token is misplaced - it must be just prior to a behavior or example token
compiler.warn.jml.missing.semi=\
    Inserting missing semicolon at the end of a {0} statement
compiler.err.jml.misplaced.var.spec=\
	This {0} clause must directly follow a field declaration
compiler.err.jml.misplaced.method.spec=\
	Method specifications must immediately precede a method or initializer declaration
compiler.err.jml.mixed.implies=\
	==> and <== operators may not be mixed without parentheses
compiler.err.jml.bad.store.ref=\
	Incorrectly formed or terminated store-reference near here
compiler.err.jml.bad.construct=\
	Incorrectly formed or terminated {0} near here
compiler.err.jml.ident.or.star.after.dot=\
	Expected an identifier or star after the dot
compiler.err.jml.expected=\
	Expected {0}
compiler.err.jml.expected.id=\
	Expected an identifier after the dot in this context
compiler.err.jml.expected.rbracket.star=\
	Expected a right bracket after the star
compiler.err.jml.expected.rbracket=\
	Invalid expression or missing right bracket
compiler.err.jml.invalid.expression.succeeding.token=\
	An invalid expression or succeeding token near here
compiler.err.jml.naked.this.super=\
	A this or super token must be followed by a field selection
compiler.err.jml.not.after.star=\
	Further selection is not permitted after a wild-card field
compiler.err.jml.not.an.array=\
	The expression preceding the array element selection does not have array type: {0}
compiler.warn.jml.example.keyword=\
	A {1} specification case {0} appear in a for_example section
compiler.err.jml.loop.spec.misplaced=\
	Loop specifications must immediately precede a while or for statement
compiler.err.jml.invalid.type.modifier=\
	A {0} token is not valid as a type modifier
compiler.err.jml.outofscope=\
	A {0} token is used outside the scope of a foreach loop
compiler.err.jml.notforthisloop=\
	The {0} token is not defined for the enclosing loop
compiler.warn.jml.refining.required=\
    A refining statement is required for statement specifications in strict JML mode
compiler.warn.jml.deprecated.left.arrow.in.represents=\
	The left arrow is deprecated in represents clauses, use = instead
compiler.err.jml.invalid.keyword.in.spec=\
	This is not a valid keyword in a method specification: {0}
compiler.err.jml.invalid.also=\
	An also token may not follow a refining token
compiler.err.jml.no.mods.in.refining=\
	No modifiers are allowed in the body of a refining statement
compiler.err.jml.bad.statement.in.set.debug=\
    A set or debug statement may only contain assignments or method calls
compiler.warn.jml.no.model.method.implementation=\
    JML model field is not implemented: {0}
compiler.warn.jml.no.model.method.ignore=\
    JML ignoring statement because model field is not implemented: {0}
compiler.err.jml.misplaced.count=\
	{0} token used outside a loop
compiler.err.jml.unrecoverable=\
    Unrecoverable situation: {0}
compiler.warn.jml.not.strict=\
    The {0} construct is an OpenJML extension to JML and not allowed under -lang=jml
compiler.err.jml.file.class.mismatch=\
    A class is not defined in the expected file: {0}
compiler.warn.jml.refining.specs.not.implemented=\
    Refining specifications (pre- and post-conditions on method statements) are not yet implemented and are ignored            						
## Modifier errors
compiler.err.jml.illegal.annotation=\
	This JML modifier is not allowed for a {0}
compiler.err.jml.mismatched.modifiers=\
	The type {0} in the specification matches a Java type {1} with different modifiers: {2}
compiler.err.jml.mismatched.field.modifiers=\
	The field {0} in the specification matches a Java field {1} with different modifiers: {2}
compiler.err.jml.mismatched.method.modifiers=\
    The method {0} in the specification matches a Java method {1} with different modifiers: {2}
compiler.err.jml.mismatched.parameter.modifiers=\
    The parameter {0} has different modifiers in the .java and .jml files: {2}
compiler.warn.jml.java.annotation.superseded=\
    Annotations in a .java file are superseded (and ignored) by the specifications in the corresponding .jml file: {0} {1}, annotation {2}
compiler.err.jml.no.mods.allowed=\
	No modifiers are allowed prior to a {0} token
compiler.err.jml.no.mods.on.import=\
	No modifiers are allowed on an import statement
compiler.err.jml.no.java.mods.allowed=\
	No Java modifiers are allowed in a {0}
compiler.err.jml.different.modifiers=\
	The specification must have the same Java modifiers as the Java declaration: {0}
compiler.err.jml.missing.annotation=\
	The specification must include all the annotations that the Java declaration declares: {0}
compiler.err.jml.no.mods.lightweight=\
	No modifiers are allowed prior to a lightweight specification case
compiler.err.jml.bad.mods.spec.case=\
	Only access modifiers are allowed for specification cases, not these: {0}
compiler.err.jml.bad.mods=\
	These modifiers are not allowed here: {0}
compiler.err.jml.no.nested.model.type=\
	A model type may not contain model declarations
compiler.err.jml.no.nested.ghost.type=\
	A model type may not contain ghost declarations
compiler.err.jml.conflicting.modifiers=\
	A declaration may not be both {0} and {1}
compiler.err.jml.missing.model=\
	A method or type declaration within a JML annotation must be model
compiler.err.jml.duplicate.model=\
	A model type may not match a Java type declaration
compiler.err.jml.missing.ghost.model=\
	A declaration within a JML annotation must be either ghost or model
compiler.err.jml.missing.ghost=\
	A local declaration within a JML annotation must be ghost
compiler.err.jml.ghost.model.on.java=\
	A Java declaration (not within a JML annotation) may not be either ghost or model
compiler.err.jml.ghost.on.java=\
	A Java local variable declaration (not within a JML annotation) may not be ghost
compiler.err.jml.no.code.lightweight=\
	Lightweight specifications may not be labeled as \'code\'
compiler.err.jml.represents.bad.static=\
	A represents clause and its associated model field must both be static or both not be static
compiler.err.jml.represents.expected.model=\
	The target of a represents clause must be a model field
compiler.err.jml.unexpected.or.misspelled.jml.token=\
    Unexpected or misspelled JML token: {0}
compiler.err.jml.visibility=\
    An identifier with {0} visibility may not be used in a {2} clause with {1} visibility
compiler.err.jml.helper.must.be.private=\
    A helper method must be private or pure: {0}
compiler.err.jml.bad.keyword=\
    A JML annotation must start with a JML keyword or have a Model or Ghost annotation: {0}
   							
## Typechecking errors
compiler.err.jml.one.arg=\
    A {0} expression expects just 1 argument, not {1}
compiler.err.jml.wrong.number.args=\
	A {0} expression expects just {1} arguments, not {2}
compiler.err.jml.arg.must.be.boolean=\
	The {0} side of the {1} operator should have boolean type, instead of {2}
compiler.err.jml.arraytype.required=\
    The argument of {0} must have array type, not {1}: {2}
compiler.err.jml.no.typeargs.for.fcn=\
	The JML function {0} may not have type arguments
compiler.err.jml.no.body.allowed=\
	A Java signature in a specification file may not have a body
compiler.warn.jml.did.not.attribute.specs.cuz.no.body=\
	Did not type-check the method specifications because there was no body to set an environment
compiler.warn.jml.inline.should.be.final=\
    Inlined methods should be final since overriding methods will be ignored: {0}
compiler.err.jml.old.must.have.init=\
	A \'old\' method clause variable must have an initializer
compiler.err.jml.forall.no.init=\
	A forall method clause declaration must not have initializers
compiler.err.jml.misplaced.same=\
	A \\same token may only be used in requires clauses
compiler.err.jml.ref.arg.required=\
	The argument of {0} must be of reference type
compiler.err.jml.one.initializer.spec.only=\
	Only one initializer specification and one static_initializer specification are allowed
compiler.err.jml.non.pure.method=\
	A non-pure method is being called where it is not permitted: {0}
compiler.warn.jml.non.pure.method=\
	A non-pure method is being called where it is not permitted: {0}
compiler.err.jml.no.assign.in.pure=\
	Assignments are not allowed where pure expressions are expected
compiler.err.jml.no.incdec.in.pure=\
	Increment and decrement operators are not allowed where pure expressions are expected
compiler.err.jml.elemtype.expects.classtype=\
	The argument of \\elemtype function must have type \\TYPE (java.lang.Class), not {0}
compiler.err.jml.datagroup.must.be.model.in.maps=\
	Datagroups in \"in\" and \"maps\" clauses must be model variables
compiler.err.jml.instance.in.static.datagroup=\
	A non-static variable may not be in a static datagroup
compiler.err.jml.incorrect.method.owner=\
	The method must be a direct member of the class containing the constraint clause
compiler.err.jml.no.constructors.allowed=\
	Constructors are not allowed as methods in non-static constraint clauses
compiler.err.jml.ident.not.in.class=\
	The identifier must be a member of the enclosing class: {0} is in {1} instead of {2}
compiler.err.jml.visibility.is.different=\
    The visibility of the readable/writable clause must be the same as the visibility of the identifier: {0} vs. {1}
compiler.warn.lock.ops=\
	Operators < and <= are deprecated as lock comparisons - use <# and <#= instead
compiler.err.jml.incomplete.implementation=\
	The implementation is incomplete (please report): {0}
compiler.warn.jml.redundant.visibility=\
	There is no point to a declaration being both {0} and {1}
compiler.err.jml.monitors.is.primitive=\
	The expression in a monitors_for clause must have reference type
compiler.err.jml.invalid.unboxing=\
	(Internal Error) Unexpected attempt to unbox an expression to an invalid target type {0}
compiler.err.jml.no.such.model.field=\
	There is no model field or datagroup named {0} in the class or its super types
compiler.err.jml.no.such.field=\
	There is no field or datagroup named {0} in the class or its super types
compiler.err.jml.not.both.query.and.secret=\
	A method may not be both secret and query for the same datagroup
compiler.err.jml.datagroup.must.be.model=\
	A datagroup must be declared model
compiler.err.jml.no.arg.for.field.secret=\
	A secret declaration for a field may not have arguments
compiler.err.jml.secret.field.in.nonsecret.datagroup=\
	A datagroup for a secret field must be secret
compiler.err.jml.nonsecret.field.in.secret.datagroup=\
	A datagroup for a non-secret field must be non-secret
compiler.err.jml.secret.field.model.or.in.secret.datagroup=\
	A secret field must be a model field or in a secret datagroup
compiler.err.jml.circular.datagroup.inclusion=\
	This field participates in a circular datagroup inclusion chain: {0}
compiler.warn.jml.circular.datagroup.inclusion.self=\
	Do not include a datagroup in itself: {0}
compiler.err.jml.not.writable.in.secret=\
	Assignment to this lhs is not allowed in a secret context
compiler.err.jml.secret.requires.arg=\
	A @Secret annotation requires an argument in this context
compiler.err.jml.represents.does.not.match.id.secret=\
	A represents clause and its identifier must both be secret or both not be secret
compiler.err.jml.no.arg.for.secret.represents=\
	A secret declaration for a represents clause may not have arguments
compiler.err.jml.only.class.cast.to.type=\
	A cast to \\TYPE may be applied only to expressions of type Class, not {0}
compiler.err.jml.subtype.arguments.same=\
	The arguments to <: must both be \\TYPE or both be Class
compiler.err.jml.open.may.not.call.secret=\
	A non-secret, non-query method may not call a secret method
compiler.err.jml.incorrect.datagroup=\
	A method called by a query or secret method must belong to the same datagroup
compiler.err.jml.lbl.in.quantified=\
    A JML label expression may not be within a quantified or set-comprehension expression
compiler.err.jml.recursive.invariants=\
    Recursive attempt to assert or assume invariants - use pure helper methods: {0}
compiler.err.jml.no.formals.in.assignable=\
    An assignable clause may not contain method formal parameters: {0}
compiler.err.jml.keyword.instead.of.ident=\
    Expected an identifier, found a JML keyword instead: {0}
compiler.err.jml.end.instead.of.ident=\
    Expected an identifier, found end of JML comment instead
compiler.err.jml.invalid.erasedtype=\
    The argument of a \\type construct must be a fully parameterized type: {0}
compiler.err.jml.no.wildcards.in.type=\
    Wildcards are not allowed within \\type expressions: {0}
compiler.err.jml.bad.quantifer.expression=\
    The value expression of a sum or product expression must be a numeric type, not {0}
compiler.err.jml.helper.required.in.represents=\
	A method called in a represents clause must be a helper method: {0}
compiler.err.jml.extra.also=\
    Method {0} does not override parent class methods and so its specification may not begin with ''also''
compiler.warn.jml.extra.also=\
    Method {0} does not override parent class methods and so its specification may not begin with ''also''
compiler.err.jml.missing.also=\
    Method {0} overrides parent class methods and so its specification should begin with ''also''
compiler.warn.jml.missing.also=\
    Method {0} overrides parent class methods and so its specification should begin with ''also''
        					
## Specification errors
compiler.warn.jml.no.point.to.more.visibility=\
    There is no point to a specification case having more visibility than its method
compiler.err.jml.orphan.jml.class.decl=\
	This specification declaration of type {0} does not match any Java type declaration in {1}
compiler.err.jml.orphan.jml.toplevel.class.decl=\
	This specification declaration of type {0} does not match any Java type declaration in {1}
compiler.err.jml.duplicate.jml.class.decl=\
	This specification declaration of type {0} has the same name as a previous JML type declaration
compiler.err.jml.no.method.match=\
	The method {0} is a Java method (neither ghost nor model) but does not match any methods in the corresponding Java class.
compiler.err.jml.no.var.match=\
	The field {0} is a Java field (neither ghost nor model) but does not match any fields in the corresponding Java class.
compiler.err.jml.duplicate.var.match=\
	This specification declaration of field {0} has the same name as a previous field declaration
compiler.err.jml.duplicate.var.binary.match=\
	This specification declaration of field {0} has the same name as a field in the binary class
compiler.err.jml.duplicate.method.match=\
	Method {0} is already defined in class {1}
compiler.err.jml.duplicate.method.binary.match=\
	This specification declaration of method {0} has the same name and signature as a method in the binary class
compiler.err.jml.mismatched.type.parameters=\
	The specification type named {0} ({1}) with {2} type parameters matches a Java type with {3} type parameters
compiler.err.jml.mismatched.type.parameter.name=\
	The specification type named {0} ({1}) has a type parameter named {2} but the Java declaration has that type parameter named {3}
compiler.err.jml.initializer.block.allowed=\
	Initializer blocks are not allowed in specifications
compiler.err.jml.misplaced.static.represents=\
	A represents clause must be declared in the same class as the static model field it represents
compiler.err.jml.misplaced.clause=\
	{0} clauses are not permitted in {1} specification cases
compiler.err.jml.misplaced.modelprogram.statement=\
	{0} statements are only allowed in model programs
compiler.err.jml.function.must.have.immutable=\
	A non-static function method must be a member of a Immutable class
compiler.err.jml.function.method=\
	Function methods are implicitly pure and may not assign to any fields: {0}
compiler.err.jml.pure.method=\
	Pure methods may not assign to any fields: {0}
compiler.err.jml.pure.constructor=\
	Pure constructors may not assign to any fields other than non-static member fields: {0}
compiler.err.jml.multiple.signalsonly=\
	At most one signals_only clause is permitted in a specification case
compiler.err.jml.missing.spec.superclass=\
	The specification file for {0} is missing a super type, expected {1}
compiler.err.jml.incorrect.spec.superclass=\
	The specification file for {0} has an incorrect superclass ({1}), expected {2}
compiler.err.jml.missing.spec.interface=\
	The specification file for {0} implements the interface {1}, which Java does not directly implement
compiler.err.jml.unimplemented.spec.interface=\
	The specification file for {0} does not implement the interface {1}
compiler.err.jml.associated.decl=\
    Associated declaration
compiler.err.jml.associated.decl.cf=\
    Associated declaration: {0}
compiler.warn.jml.associated.decl=\
    Associated declaration
compiler.warn.jml.associated.decl.cf=\
    Associated declaration: {0}
compiler.err.jml.mismatched.package=\
	Specification package does not match Java package: {0} vs. {1}
compiler.err.jml.unmatched.type=\
    This type declaration ({0}) is not matched by a binary class
compiler.warn.jml.unmatched.type=\
    This type declaration ({0}) is not matched by a binary class
compiler.err.jml.no.secret.in.open.context=\
	Secret fields may not be read in non-secret context: {0}
compiler.err.jml.not.in.secret.context=\
	A field may not be read in a secret context unless it is in the same secret datagroup: {0} not in {1}
compiler.err.jml.not.writable.in.secret.context=\
	The field {0} is not writable since it is not in the {1} secret datagroup
compiler.err.jml.secret.invariant.one.arg=\
	A secret annotation on an invariant must have exactly one argument
compiler.err.jml.secret.method.one.arg=\
	A secret annotation on a method must have exactly one argument
compiler.err.jml.annotation.arg.not.a.field=\
	The argument to a secret or query annotation must be a field: {0}
compiler.warn.jml.possibly.recursive.invariant=\
    Calling a pure non-helper method in an invariant may lead to unbounded recursive invariant checks and stack-overflow: {0}
compiler.err.jml.no.old.in.constructor=\
    Non-static fields are not allowed in \\old environments in postconditions: {0}
compiler.err.jml.no.result.in.old=\
    A \\result expression is not allowed in an old environment
compiler.err.jml.no.star.in.strict.mode=\
    Strict JML does not allow the [*] syntax
compiler.err.jml.unimplemented.lambda=\
    Unimplemented binary operation involving lambda expressions
compiler.err.jml.bad.lambda.conversion=\
    Trying to convert a lambda expression to a non-functional interface: {0}
compiler.err.jml.bad.method.reference.conversion=\
    Trying to convert a method reference {0} to a non-functional interface: {1}
compiler.err.jml.no.default.constructor=\
	There is no default constructor to match this specification    					 	
## Tool and environment errors
compiler.warn.jml.specs.dir.not.exist=\
	A specification path directory does not exist: {0}
compiler.err.jml.main.null.args=\
	The main entry point {0} was called with a null argument
compiler.warn.jml.no.specs=\
	The java file {0} has no specifications and is not itself on the specifications path - using it as its own specification file anyway	
compiler.err.jml.no.spec.file=\
	No specification file was found on specs path for class {0} despite it having been parsed from the source file {1}; using the source file as the specification file, but you should fix the specs path
compiler.warn.jml.bad.sp.var=\
	{0} is included in the specs path recursively or multiple times
compiler.note.jml.stop=\
	Stopping because of parsing errors
compiler.note.jml.continue=\
	Continuing bravely despite parsing errors
compiler.warn.jml.no.internal.specs=\
	Could not locate the internal specifications files - you may need to add the jmlspecs.jar explicitly on the command-line using -specspath.
compiler.warn.jml.no.internal.runtime=\
	Could not locate the internal runtime classes - you may need to add the jmlruntime.jar explicitly on the command-line using -classpath.
compiler.err.jml.internal.specs.dir.not.exist=\
	The setting of openjml.eclipseSpecsProjectLocation used for testing is not correct ({0}).  It should contain the absolute path of the Specs project; you should set it as a VM argument in run Run Configuration for tests, as in -Dopenjml.eclipseSpecsProjectLocation=...
compiler.err.jml.internal.specs.dir.not.defined=\
	The java environment variable openjml.eclipseSpecsProjectLocation used for testing must be defined.  It should contain the absoluite path of the Specs project; you should set it as a VM argument in run Run Configuration for tests, as in -Dopenjml.eclipseSpecsProjectLocation=...
compiler.err.jml.toplevel.exception=\
	The compiler aborted with an uncaught exception: {0}
compiler.err.jml.unexpected.code.branch=\
	The tool took an unexpected (and unimplemented) code branch: {0}
compiler.warn.jml.ignoring.options=\
    The options argument to Main.execute is ignored when compiling java-only
compiler.warn.jml.ignoring.parameter=\
    This command-line option is not supposed to have a parameter: {0}
compiler.warn.jml.expected.parameter=\
    The last command-line option expects a parameter: {0}
compiler.warn.jml.command.line.arg.not.a.file=\
    An item on the command-line does not appear to be a file or directory: {0}
compiler.warn.jml.ignoring.non.string.key=\
    Ignoring an environment key that is not a string, but a {0}
compiler.warn.jml.ignoring.non.string.value=\
    Ignoring an environment value that is not a string, but a {0}, for key {1}
compiler.err.jml.process.args.exception=\
    An IOException occurred while processing command-line arguments: {0}
compiler.warn.jml.ignore.extra.material=\
    Ignoring unrecognized material in the args parameter of Main.initializeOptions: {0}
compiler.err.jml.last.option.wants.parameter=\
    The last item on the command-line expects a parameter: {0}
compiler.err.jml.option.is.not.a.file.or.dir=\
    A command-line item is not a file or directory: {0}
compiler.err.jml.no.java.file=\
    There is no java or binary file on the sourcepath corresponding to the given jml file: {0}
compiler.warn.jml.no.java.file=\
    There is no java or binary file on the sourcepath corresponding to the given jml file: {0}
             
## Input data errors
compiler.err.jml.bad.secondary.type=\
	The top-level secondary type {0} in the specification file cannot be matched to a Java type
compiler.err.jml.secondary.type.not.class.name=\
	The top-level secondary type name {0} in the specification file resolves to something other than a class as a Java identifier

## RAC errors
compiler.warn.jml.duplicate.represents=\
	Duplicate represents clause - only the first is used for RAC
compiler.warn.jml.not.implemented.rac=\
	Not implemented for runtime assertion checking: {0}
compiler.note.jml.not.implemented.rac=\
	Not implemented for runtime assertion checking: {0}
compiler.warn.jml.quantified.expression.not.translatable=\
	OpenJML is not able to execute this quantified expression for runtime assertion checking
compiler.warn.jml.skipping.no.model=\
    A clause is skipped because it contains a model field without representation: {0}

## ESC errors
compiler.err.jml.esc.badscript=\
	An error while executing a proof script for {0}: {1}
compiler.warn.jml.not.implemented.esc=\
	Not implemented for static checking: {0}
compiler.warn.esc.prover.failure=\
	Prover failed: {0}
compiler.warn.esc.vc.prep=\
	Failure while preparing VC: {0}
compiler.warn.esc.nomodel=\
    Validity is unknown - no model available {0}
compiler.warn.esc.resourceout=\
    Validity is unknown - time or memory limit reached: {0}
compiler.warn.esc.resourceout.feasibility=\
    Feasibility is unknown - time or memory limit reached: {0}
compiler.warn.esc.method.invalid=\
	Method does not appear to satisfy its specifications (no counterexample information): {0}
compiler.warn.esc.assertion.invalid=\
	The prover cannot establish an assertion ({0}{1}) in method {2}{3}
compiler.warn.esc.infeasible.assumption=\
	There is no feasible path to program point {0} in method {1}
compiler.warn.esc.infeasible.preconditions=\
	Invariants+Preconditions appear to be contradictory in method {0}
compiler.warn.esc.false.precondition.conjunct=\
	Precondition conjunct is false: {0}
compiler.warn.esc.infeasible.branch=\
	{0} branch apparently never taken in method {1}
compiler.warn.esc.infeasible.case=\
	Switch case apparently never taken in method {0}
compiler.warn.esc.label=\
    Label {0} reported
compiler.note.esc.label=\
    Label {0} reported
compiler.warn.esc.label.value=\
    Label {0} has value {1}
compiler.note.esc.label.value=\
    Label {0} has value {1}
compiler.warn.esc.label.expr=\
    Show statement expression {0} has value {1}
compiler.note.esc.label.expr=\
    Show statement expression {0} has value {1}
compiler.note.esc.checking.method=\
	Checking method {0}
compiler.err.esc.proof.failed=\
	Unexpected result from prover ({0}) while checking method {1}
compiler.err.esc.no.prover=\
	No prover interface found for prover {0}
compiler.err.esc.create.prover.exception=\
	Failed to create a prover process for prover {0}: {1}
compiler.err.esc.internal.error=\
	INTERNAL ERROR: {0}
compiler.warn.esc.internal.error=\
	INTERNAL ERROR: {0}
compiler.note.esc.not.implemented=\
    NOT IMPLEMENTED: {0}
compiler.warn.esc.not.implemented=\
    NOT IMPLEMENTED: {0}
compiler.err.esc.not.implemented=\
	NOT IMPLEMENTED: {0}
compiler.err.esc.prover.failure=\
	Prover failure: {0}
compiler.err.esc.retract.not.supported=\
	Proof attempt aborted because using retract was selected but is not supported by {0}
compiler.err.esc.unsatcore.not.supported=\
	Proof attempt aborted because unsat-core was selected but not is supported by {0}
	
## jmldoc errors
compiler.err.jmldoc.toplevel.exception=\
	jmldoc aborted with an uncaught exception: {0}
compiler.err.jmldoc.main.null.args=\
	An entry point in {0} was called with a null argument
				
## Incomplete implementation or internal errors
compiler.err.jml.unknown.operator=\
	An unknown operator {0} is not implemented in {1}
compiler.err.jml.unknown.construct=\
	An unknown construct {0} is not implemented in {1}
compiler.err.jml.unknown.statement=\
	An unknown or not implemented JML statement type was encountered: {0}
compiler.warn.jml.unimplemented.construct=\
	The construct {0} is not yet implemented ( {1} )
compiler.err.jml.unimplemented.construct=\
	The construct {0} is not yet implemented ( {1} )
compiler.err.jml.unknown.type.token=\
	The token {0} is unknown in {1} - please report the bug	
compiler.warn.jml.internal.notsobad=\
	An internal JML error occurred, possibly recoverable.  Please report the bug with as much information as you can.\nReason: {0}
compiler.err.jml.internal.notsobad=\
	An internal JML error occurred, possibly recoverable.  Please report the bug with as much information as you can.\nReason: {0}
compiler.err.jml.internal=\
    A catastrophic JML internal error occurred.  Please report the bug with as much information as you can.\nReason: {0}
compiler.warn.jml.internal=\
    JML internal problem: {0}
compiler.note.esc.not.implemented=\
    Not implemented for static checking: {0}
compiler.note.rac.not.implemented=\
    Not implemented for runtime assertion checking: {0}
compiler.note.rac.not.implemented.quantified=\
    Runtime assertion checking is not implemented for this type or number of declarations in a quantified expression
compiler.err.esc.no.exec=\
    The executable for prover {0} is not specified - use -exec or define an openjml.prover.... property
compiler.err.esc.no.typechecking=\
    ESC could not be attempted because of a failure in typechecking or AST transformation: {0}
compiler.err.esc.incomplete.typechecking=\
    ESC could not be completed because of incomplete or errors in typechecking    
## Problems with solvers
compiler.err.jml.smt.error=\
    Error occurred while attempting proof: {0}
compiler.err.jml.solver.failed.to.start=\
    The solver failed to start: {0}

## UNCATEGORIZED - FIXME


compiler.err.jml.expected.semicolon.quantified=\
	Expected a semicolon to separate the parts of a JML quantified expression
compiler.err.jml.max.expects.lockset=\
	A \\max function expects an argument of type {0} rather than {1}
compiler.err.jml.illformed.model.import=\
	A model import declaration must be completely within a JML comment
compiler.err.jml.import.no.model=\
	An import statement in a JML comment must have a model modifier


compiler.err.jml.mismatched.type.arguments=\
	The type {0} in the specification matches a Java type {1} with a different number of type arguments
compiler.err.jml.no.initializer.in.specs=\
	Field initializers are not permitted in specification files ({0})
compiler.err.jml.mismatched.field.types=\
	The field {0} in the specification matches a Java field {1} but they have different types: {2} vs. {3}
compiler.err.jml.mismatched.param.names=\
	Parameter {0} of method {1} has name {2} in the .java file but {3} in the specification (they should be the same)
compiler.err.jml.no.body.allowed=\
	The specification of the method {0} must not have a body
compiler.err.jml.mismatched.return.type=\
	The return types of method {0} are different in the specification and java files: {1} vs. {2}
compiler.err.jml.expected.lparen.signals=\
	Expected a left parenthesis after a signals keyword
compiler.err.jml.expected.rparen.signals=\
	Expected a right parenthesis after a signals keyword
compiler.err.jml.missing.semi=\
	Invalid expression or missing semicolon here
compiler.err.jml.use.nothing=\
	Use \\nothing to denote an empty list of exceptions in a {0} clause
compiler.err.jml.missing.comma=\
	Missing comma or otherwise ill-formed type name
compiler.err.jml.subtype.arguments=\
	The type of the arguments of the subtype operator (<:) must be either \\TYPE or java.lang.Class, not {0}
compiler.err.jml.expected.semi.after.nothing=\
    Expected a semicolon following the \\nothing token
compiler.err.jml.missing.semicolon.in.show=\
	Expected a semicolon to terminate the expression list
compiler.err.jml.bad.expression.list.in.show=\
	Bad syntax in the expression list in show statement
   
compiler.err.jml.misplaced.result=\
	A \\result expression may not be in a {0} clause
compiler.err.jml.misplaced.token=\
	A {0} expression may not be in a {1} clause
compiler.err.jml.illegal.token.for.declaration=\
	The token {0} is illegal or not implemented for a type or method clause (JmlParser.classOrInterfaceBodyDeclaration)
compiler.err.jml.misplaced.old=\
	A {0} may not be present in a {1} clause
compiler.err.jml.bad.label=\
    The second argument of an \\old expression must be a simple identifier that is a label
compiler.err.jml.unknown.label=\
    There is no label named {0}
compiler.err.jml.void.result=\
	A \\result expression may not be used in the specification of a method that returns void
compiler.err.jml.bad.bstype.expr=\
	More than one argument or otherwise ill-formed type expression as argument of \\type
compiler.err.jml.two.refines.clauses=\
	A compilation unit may have at most one refines clause
compiler.warn.rac.Assert=\
    JML assertion is false
compiler.warn.rac.Assume=\
    JML assumption is false
compiler.warn.rac.PossiblyDivideByZero=\
    JML Division by zero
compiler.warn.rac.UndefinedDivideByZero=\
    JML Division by zero
compiler.warn.rac.Postcondition=\
    JML postcondition is false
compiler.warn.rac.Precondition=\
    JML precondition is false
compiler.warn.rac.NullCheck=\
    JML value possibly null
compiler.warn.rac.NullField=\
    JML non-null field is null
compiler.warn.rac.StaticInit=\
    JML static initialization may not be correct: {0}
compiler.warn.rac.BranchThen=\
    JML branch is false
compiler.warn.rac.BranchElse=\
    JML branch is false
compiler.warn.rac.Unreachable=\
    JML unreachable statement reached
compiler.warn.rac.PossiblyNullInitialization=\
    JML null initialization of non_null field {0}
compiler.warn.rac.PossiblyNullDeReference=\
    JML A null object is dereferenced
compiler.warn.rac.UndefinedNullDeReference=\
    JML A null object is dereferenced within a JML expression
compiler.warn.rac.PossiblyNullValue=\
    JML An object may be illegally null
compiler.warn.rac.UndefinedNullValue=\
    JML An object may be illegally null within a JML expression
compiler.warn.rac.PossiblyNullUnbox=\
    JML Attempt to unbox a null object
compiler.warn.rac.UndefinedNullUnbox=\
    JML Attempt to unbox a null object within a JML expression
compiler.warn.rac.PossiblyBadCast=\
    JML A cast is invalid - from {0} to {1}
compiler.warn.rac.UndefinedBadCast=\
    JML A cast is invalid - from {0} to {1}
compiler.warn.rac.Assignable=\
    JML An item is assigned that is not in the assignable statement: {0}
compiler.warn.rac.Invariant=\
    JML invariant is false
compiler.warn.rac.InvariantEntrance=\
    JML invariant is false on entering method {0}
compiler.warn.rac.InvariantExit=\
    JML invariant is false on leaving method {0}
compiler.warn.rac.InvariantReenterCaller=\
    JML caller invariant is false on reentering calling method {0}
compiler.warn.rac.InvariantLeaveCaller=\
    JML caller invariant is false on leaving calling method {0}
compiler.warn.rac.PossiblyNullAssignment=\
    JML assignment of null to a non_null variable
compiler.warn.rac.ExceptionalPostcondition=\
    JML signals condition is false
compiler.warn.rac.ExceptionList=\
    JML unexpected exception for the signals_only clause
compiler.warn.rac.Constraint=\
    JML constraint clause is false on leaving method
compiler.warn.rac.LoopInvariantAssumption=\
    JML loop invariant is false at beginning of loop body
compiler.warn.rac.LoopInvariant=\
    JML loop invariant is false at end of loop body
compiler.warn.rac.LoopInvariantPreLoop=\
    JML loop invariant is false
compiler.warn.rac.LoopInvariantBeforeLoop=\
    JML loop invariant is false before entering loop
compiler.warn.rac.LoopInvariantAfterLoop=\
    JML loop invariant is false after exiting loop
compiler.warn.rac.LoopDecreases=\
    JML loop variant does not decrease
compiler.warn.rac.LoopDecreasesNonNegative=\
    JML loop variant is negative
compiler.warn.rac.PossiblyNegativeSize=\
    JML attempt to create an array with negative size
compiler.warn.rac.PossiblyLargeShift=\
    JML shift amount is out of expected range
compiler.warn.rac.Initially=\
    JML initially clause is false at exit from constructor
compiler.warn.rac.PossiblyNegativeIndex=\
    JML the array index is negative
compiler.warn.rac.UndefinedNegativeIndex=\
    JML expression is undefined because of a negative array index
compiler.warn.rac.PossiblyTooLargeIndex=\
    JML the array index is too large
compiler.warn.rac.UndefinedTooLargeIndex=\
    JML expression is undefined because of an array index that is too large
compiler.warn.rac.ImplicitAssume=\
    JML an implicit assumption is false (internal error)
compiler.warn.rac.UndefinedCalledMethodPrecondition=\
    JML a method called in a JML expression is undefined because its precondition is false
compiler.warn.rac.ArithmeticOperationRange=\
    JML result of numeric operation is out of range of the target type
compiler.warn.rac.ArithmeticCastRange=\
    JML argument to numeric cast is out of range of the target type
compiler.warn.rac.Readable-if=\
    JML readable clause is false for variable {0}
compiler.warn.rac.Writable-if=\
    JML writable clause is false for variable {0}
compiler.warn.rac.PossiblyBadArrayAssignment=\
    JML the dynamic type of the rhs is not a subtype of the dynamic element type of the lhs (will throw ArrayStoreException)