\input texinfo
@c %**start of header
@setfilename OpenJML.info
@settitle OpenJML User Guide
@c %**end of header

%%@copying ZZZZZZ
@setchapternewpage odd
@titlepage
@sp 10
@center @titlefont{OpenJML User Guide}
@center David R. Cok
@center 3 March 2013
@sp 2
@center{DRAFT IN PROGRESS}
@sp 1
%%The most recent version of this document is available at \url{http://jmlspecs.sourceforge.net/OpenJMLUserGuide.pdf}.\\
 %%\vspace*{2.3in}
\parbox{\textwidth}{Copyright (c) 2010-2013 by David R. Cok. Permission is granted to make and distribute copies of this document for educational or research purposes, provided that the copyright notice and permission notice are preserved and acknowledgment is given in publications. 
Modified versions of the document may not be made. Please forward corrections to the author.
Incorporating this document within a larger collection, or distributing it for commercial purposes, or including it as part or all of a product for sale is allowed only by separate written permission from the author.}}

@end titlepage

@contents

@ifnottex
@node Top
@top OpenJML User Guide

%%@insertcopying
@end ifnottex


@part OpenJML

@chapter Introduction 
@section JML

{\it This section will be added later.} %% TBD

@section OpenJDK

\textit{This section will be added later.} %% TBD


@section OpenJML

\textit{This section will be added later.} %% TBD


@section License

The OpenJML command-line tool is built from OpenJDK, which is licensed under GPLv.2 (\url{http://openjdk.java.net/legal/}).
Hence OpenJML is correspondingly licensed.

The OpenJML plug-in is a pure Eclipse plug-in, and therefore is not required to be licensed under the EPL.
It does, however, call the command-line tool (in a Java sort of way), so it may be considered to be GPL v.2 as well.

In any case, the source code for both tools is available as a sourceforge project at
\url{http://jmlspecs.svn.sourceforge.net/viewvc/jmlspecs/OpenJML/}.


@chapter The command-line tool 
@ifset AA
\section{Installation and System Requirements}

The command-line tool is supplied as a .tar.gz file, downloadable from \url{http://jmlspecs.sourceforge.net/}.
Download the file to a directory of your choice and unzip and untar it in place.
It contains the following files:
\begin{itemize}\nospace
\item openjml.jar - the main jar file for the application
\item jmlruntime.jar - a library needed on the classpath when running OpenJML on Java files
\item jmlspecs.jar - a library containing specification files
\item openjml-template.properties - a sample file, which should be copied and renamed {\tt openjml.properties},
containing definitions of properties whose values depend on your local system
\item LICENSE.rtf - a copy of the modified GPL license that applies to OpenJDK and OpenJML
\item epl-v10.html - a copy of the EPL license
\item OpenJMLUserGuide.pdf - this document
\end{itemize}

You can run OpenJML in a Java 1.7 JRE or, with a bit of work-around, in a Java 1.6 JRE.
\footnote{This situation appears to result from how the Java class loader handles static fields, such as Enum constants.}

\paragraph{Java 1.7}
Java 1.7 is not quite released, but you can obtain a version suitable for running OpenJML from these locations:
\begin{itemize} \nospace
\item for Windows and Linux: \url{http://dlc.sun.com.edgesuite.net/jdk7/binaries/index.html}. For testing on Windows/Cygwin, I have been using build 103, from July 2010, which you can download from \url{http://jmlspecs.sourceforge.net/openjdk-7-ea-src-b103-29_jul_2010.zip}
\item for MacOS X: \url{http://formalmethods.insttech.washington.edu/software/openjml.html}
\end{itemize}
Note that the 1.7 JRE must be the current JRE in the system or the shell in which you run OpenJML.

You should also be sure that the {\tt jmlruntime.jar} and {\tt jmlspecs.jar} files remain
in the same folder as the {\tt openjml.jar} file.

\paragraph{Java 1.6}
If you use Java 1.6, you need to add the {\tt openjml.jar} library at the beginning of the bootclasspath, as shown in the next section.

\section{Running OpenJML}
\label{Running}

To run OpenJML using a Java 1.7 VM, use this command line. Here \${OpenJML} designates the folder in which the {\tt openjml.jar} file resides.
\boxedexampleZ{
java -jar \${OPENJML}/openjml.jar {\it <options>} {\it <files>}
}

Here {\it <files>} and {\it <options>} stand for text described below.

The following command is currently a viable alternative as well.
\boxedexampleZ{
java -cp \${OPENJML}/openjml.jar org.jmlspecs.openjml.Main {\it <options>} {\it <files>}
}

The valid options are listed in Table \ref{Tab:Options} and are described in subsections below.

For a 1.6 VM (on Windows/Cygwin only), use this command-line:
\boxedexampleZ{
java -Xbootclasspath/p:\${OPENJML}/openjmlboot.jar -jar \${OPENJML}/openjml.jar {\it <options>} {\it <files>}
}

\subsection{Files}

In the command templates above, {\it <files>} refers to a list of {\tt .java} files.
Each one must be specified with an absolute file system path or with a path relative
to the current working directory (in particular, not with respect to the classpath or
the sourcepath). 

You can also specify directories on the command line using the {\tt -dir} and {\tt -dirs} options.
The {\tt -dir {\it <directory>}} option indicates that the {\it <directory>} value (an absolute or
relative path to a folder) should be understood as a folder; all {\tt .java} or specification files
within the folder are including as if they were individually listed on the command-line. The
{\tt -dirs} option indicates that each one of the remaining command-line arguments is interpreted as 
either a source file (if it is a file with a {\tt .java} suffix) or as a directory (if it is a directory)
whose contents are processed as if listed on the command-line. Note that the {\tt -dirs} option must be
the last option.

TBD: specification files - are they processed as well?

\subsection{Specification files}

{\it TBD : to be written}

\begin{table} \small
%%\centering
\parbox{.5\textwidth}{
\begin{tabular}{|l|p{1.2in}|}
\hline
\multicolumn{2}{|c|}{Options specific to JML} \\
\hline
-- & no more options \\
-check & typecheck only ({\tt -command check})\\
-command {\it <action>}& which action to do: check esc rac compile\\
-compile & \\
-counterexample & show a counterexample for failed static checks\\
-crossRefAssociatedInfo & \\
-dir {\it <dir>} & argument is a folder of files \\
-dirs & remaining arguments are folders or files\\
-esc & do static chacking ({\tt -command esc})\\
-java & use the native OpenJDK tool\\
-jmldebug & very verbose output (includes -progress) \\
-jmlverbose & JML-specific verbose output\\
-keys & \\
-method & \\
-noCheckSpecsPath & ignore non-existent specs path entries\\
-noPurityCheck & do not check for purity \\
-noInternalSpecs & do not add internal specs library to specspath \\
-noInternalRuntime & do not add internal runtime library to classpath \\
-noJML & ignore JML constructs \\
-nonnullByDefault & values are not null by default \\
-nullableByDefault & values may be null by default\\
-progress & \\
-rac & compile runtime assertion checks ({\tt -command rac})\\
-roots & \\
-showNotImplemented & warn if feature not implemented\\
-specspath & location of specs files\\
-stopIfParseErrors & stop if there are any parse errors \\
-subexpressions & show subexpression detail for failed static checks\\
-trace & show a trace for failed static checks\\
\hline
\end{tabular}
}
\qquad
%%\centering
\parbox{.5\textwidth}{
\begin{tabular}{|l|p{1.2in}|}
\hline
\multicolumn{2}{|c|}{Options inherited from Java} \\
\hline
-Akey & \\
-bootclasspath {\it <path>}& See Java documentation. \\
-classpath {\it <path>}& location of class files \\
-cp {\it <path>}& location of class files\\
-d {\it <directory>} & location of output class files\\
-encoding {\it <encoding>} & \\
-endorsedirs {\it <dirs>} & \\
-extdirs {\it <dirs>} & \\
-deprecation & \\
-g & \\
-help & output help information\\
-implicit & \\
-J{\it <flag>} & \\
-nowarn & show only errors, no warnings \\
-proc & \\
-processor {\it <classes>} & \\
-processorpath {\it <path>} & where to find annotation processors\\
-s {\it <directory>} & location of output source files\\
-source {\it <release>} & the Java version of source files\\
-sourcepath {\it <path>} & location of source files\\
-target {\it <release>} & the Java version of the output class files\\
-X & Java non-standard extensions\\
-verbose & verbose output \\
-version & output (OpenJML) version\\
-Werror & treat warnings as errors \\
 \ & \\
\ & \\
\ & \\
\ & \\
\hline
\end{tabular}
}
\caption{OpenJML options. See the text for more detail on each option.}
\label{Tab:Options}
\end{table}

\subsection{Java properties and the {\tt openjml.properties} file}

OpenJML uses a number of properties that may be defined in the environment; these properties are
typically characteristics of the local environment and are not common across different users or
different installations. An example is the the file system location of a particular solver.

The tool looks for a file named {\tt openjml.properties} in several locations. It loads the
properties it finds in each of these, in order, so later definitions will supplant earlier ones.
\begin{itemize}\nospace
\item System properties, including those defined with {\tt -D} options on the command-line
\item On the system classpath
\item In the users home directory (the value of the Java property {\tt user.home}
\item In the current working directory (the value of the Java property {\tt user.dir}
\end{itemize}

The properties that are currently recognized are these:
\begin{itemize}\nospace
%% TBD \item {\tt openjml.option.{\it <key>}}, where {\it <key>} is the name of a command-line option and the value is the value of the option as if it were specified on the command-line; values actually specified on the command-line override any specified in a properties file
\item {\tt openjml.defaultProver} - the value is the name of the prover to use by default
\item {\tt openjml.prover.{\it <name>}}, where {\it <name>} is the name of a prover, and
the value is the file system path to the executable to be invoked for that prover
\end{itemize}

The distribution includes a file named {\tt openjml-template.properties} that contains stubs for all the recognized options.
You should copy that file, rename it as {\tt openjml.properties}, and edit it to reflect your system configuration.
(Do not commit your system's {\tt openjml.properties} file into the OpenJML shared SVN repository.)

\subsection{Options: Finding files and classes: class, source, and specs paths}

A common source of confusion is the various different paths used to find files, specs and classes in OpenJML.
OpenJML is a Java application and thus a classpath is used to find the classes that constitute the application;
but OpenJML is also a tool that processes Java files, so it uses a (different) classpath to find the files that it is processing. 
As is the case for other Java applications, a {\it <path>} contains a sequence of individual paths to folders or jar files, separated
by the path separator character (a semicolon on Windows systems and a colon on Unix and MacOSX systems).
You should distinguish the following:
\begin{itemize}
\item the classpath used to run the application: specified by one of
\begin{itemize}\nospace
\item the {\tt CLASSPATH} environment variable
\item the .jar file given with the {\tt java -jar} form of the command is used
\item the value for the {\tt -classpath} (equivalently, {\tt -cp}) option when OpenJML is run with the
{\tt java -cp openjml.jar org.jmlspecs.openjml.Main} command
\end{itemize}
This classpath is not of much concern to OpenJML, but is the classpath that Java users will be familiar with.
The value is implicitly given in the {\tt -jar} form of the command. The application classpath is explicitly given in the alternate form of the command,
and it may be omitted; if it is omitted, the value of the system property {\tt CLASSPATH} is used and it must contain the {\tt openjml.jar} library.

\item the classpath used by OpenJML. This classpath determines where OpenJML will find .class files for classes 
referenced by the {\tt .java} files it is processing. The classpath is specified by\\
\centerline{\tt -classpath {\it <path>}}
or \\
\centerline{\tt -cp {\it <path>}}
{\it after} the executable is named on the commandline.  That is,
\boxedexampleB{
java -jar openmjml.jar -cp {\it <openjml-classpath>} ...
}
or
\boxedexampleB{
java -cp openjml.jar org.jmlspecs.openjml.Main -cp {\it <openjml-classpath>} ...
}
If the OpenJML classpath is not specified, its value is obtained from the application classpath.

\item the OpenJML sourcepath - The sourcepath is used by OpenJML as the list of locations in which to find {\tt .java} 
files that are referenced by the files being processed. For example, if a file on the command-line, say {\tt T.java},
refers to another class, say {\tt class U}, that is not listed on the command-line, then {\tt U} must be found.  OpenJML (just as is done by the Java compiler) will look for a source file for {\tt U} in the sourcepath and a class file for {\tt U} in the classpath.
If both are found then TBD.

The OpenJML sourcepath is specified by the {\tt -sourcepath {\it <path>}} option. If it is not specified, the value for the sourcepath is taken to be the same as the OpenJML classpath.

In fact, the sourcepath is rarely used.  Users often will specify a classpath containing both {\tt .class} and {\it .java} files; by 
not specifying a sourcepath, the same path is used for both {\tt .java} and {\tt .class} files. This is simpler to write, but does mean
that the application must search through all source and binary directories for any particular source or binary file.

\item the OpenJML specspath - The specspath tells OpenJML where to look for specification files. It is specified with the {\tt -spacspath {\it <path>}} option. If it is not specified, the value for the specspath is the same as the value for the sourcepath.  In addition, by default, the specspath
has added to it an internal library of specifications.  These are the existing (and incomplete) specifications of the Java standard library classes.

The addition of the Java specifications to the specspath can be disabled by using the {\tt -noInternalSpecs} option.  For example. if you
have your own set of specification files that you want to use instead of the internal library, then you should use the {\tt -noInternalSpecs} option and a {\tt -specspath} option with a path that includes your own specification library.

Note also that often source ({\tt .java}) files contain specifications as well. Thus, if you are specifying a specspath yourself, you should
be sure to include directories containing source files in the specspath; this rule also includes the {\tt .java} files that appear on the 
command-line: they also should appear on the specspath.

TBD - describe what happens if the above guidelines are not followed. (Can we make this more user friendly).

\end{itemize}

\paragraph{The {\tt -noInternalSpecs} option.} As described above, this option turns off the automatic adding of the internal specifications library to the specspath. If you use this option, it is your responsibility to provide an alternate specifications library for the standard
Java class library. If you do not you will likely see a large number of static checking warnings when you use Extended Static Checking to check the implementation code against the specifications.

The internal specifications are written for programs that conform to Java 1.7.  [ TBD - change this to adhere to the {\tt -source} option?] 
[TBD - what about the specs in jmlspecs for different source levels.]

\subsection{Specification files}

JML specifications for Java classes (either source or binary) are written in files with a {\tt .jml} suffix or are written directly in the source {\tt .java} file.
When OpenJML needs specifications for a given class, it looks for a {\tt .jml} file on the specspath. If one is not found, OpenJML then looks for a {\tt .java}
file on the specspath. Note that this rule requires that source files (that have specifications you want to use) must be listed on the specspath. Note also that there 
need not be a source file; a {\tt .jml} file can be (and often is) used to provide specifications for class files.

Previous versions of JML had a more complicated scheme for constructing specifications for a class involving refinements, multiple specification files, and various prefixes. This complicated process is now deprecated and no longer supported.

[ TBD: some systems might find the first .java or .jml file on the specspath and use it, even if there were a .jml file later.]
[ TBD: Actually, as of this date, the old mechanism is still in place and the new one still in progress. ]

\subsection{Annotations and the runtime library}

JML uses Java annotations as introduced in Java 1.6. Those annotation classes are in the package
{\tt org.jmlspecs.annotation}. In order for files using these annotations to be processed by Java,
the annotation classes must be on the classpath. They may also be required when a compiled Java program
that uses such annotations is executed. In addition, running a program that has JML runtime assertion
checks compiled in will require the presence of runtime classes that define utility functions used by the assertion checking code.

Both the annotation classes and the runtime checking classes are provided in a library named {\tt jmlruntime.jar}.  The distribution of OpenJML contains this library, as well as containing a
version of the library within {\tt openjml.jar}. The OpenJML is applied to a set of classes, by default it finds a version of the runtime classes and appends the location of the runtime classes
to the classpath.

You can prevent OpenJML from automatically adding {\tt jmlruntime.jar} to the classpath with the
option {\tt -noInternalRuntime}. If you use this option, then you will have to supply your own
annotation classes and (if using Runtime Assertion Checking) runtime utility classes on the classpath. You may wish to do this, for example, if you have newer versions of the annotation
classes that you are experimenting with. You could simply put them on the classpath, since they
would be in front of the automatically added classes and used in favor of default versions;
however, if you want to be sure that the default version are not present, use the {\tt -noInternalRuntime} option.

The symptom that no runtime classes are being found at all is error messages that 
the {\tt org.jmlspecs.annotation} package is not found.

\subsection{Options: Information and debugging}
\begin{itemize}
\item -help : prints out help information about the command-line options
\item -version : prints out the version of the OpenJML tool
\item -verbose : prints out verbose information about the Java processing
\item -jmlverbose : prints out verbose information about the JML processing (includes -verbose)
\item -progress :
\item -jmldebug : prints out (voluminous) debugging information
\end{itemize}

\subsection{Options: JML tools}
\begin{itemize}
\item -command {\it <tool>} : initiates the given function; the value of {\it <tool>} may be one of {\tt check}, {\tt ese}, {\tt rac}, TBD.
The default is to use the OpenJML tool to do only typechecking of Java and JML in the source files. 
\item -check : causes OpenJML to do only type-checking of the Java and JML in the input files
\item -compile
\item -esc : causes OpenJML to do (type-checking and) static checking of the JML specifications against the implementations in the input files
\item -rac
\item -java : causes OpenJML to ignore all OpenJML extensions and use only the core OpenJDK functionality, so the tool should run precisely like the OpenJDK javac tool
\item -noJML : causes OpenJML to use its extensions but to ignore all JML constructs (TBD - does this still recognize -check, -compile?)
\end{itemize}

TBD: jmldoc?

\subsection{Options relating to Java version}

\begin{itemize}
\item -source {\it <level>} : this option specifies the Java version of the source files, with values of
{\tt 1.4}, {\tt 1.5}, {\tt 1.6}, {\tt 1.7}. This controls whether some syntax features  
(e.g. annotations, extended for-loops, autoboxing, enums) are permitted. The default is the most recent version
of Java, in this case 1.7.  Note that the classpath should include the Java library classes that
correspond to the source version being used.

\item -target {\it <level>} : this option specifies the Java version of the output class files
\end{itemize}


\subsection{Options: Java compiler options controlling output}

\begin{itemize}
\item -d {\it <dir>} : specifies the directory in which output class files are placed
\item -s {\it <dir>} : specifies the directory in which output source files are placed (such as those produced by annotation processors)
\end{itemize}


\subsection{Options related to Static Checking}
\begin{itemize}
\item -counterexample
\item -trace
\item -subexpressions
\item -method
\end{itemize}

\subsection{Options related to parsing and typechecking}
\begin{itemize}
\item -Werror
\item -nowarn
\item -stopIfParseError
\item -noCheckSpecsPath
\item -noPurityCheck
\item -nonnullbydefault
\item -nullablebydefault
\item -keys
\end{itemize}

\subsection{Options related to annotation processing}
\begin{itemize}
\item -proc
\item -processor
\item -processorpath
\end{itemize}

\subsection{Other JML Options}
\begin{itemize}
\item -showNotImplemented
\item -crossRefAssociatedInfo
\item -roots
\end{itemize}

\subsection{Other Java Options}
These options are unchanged from their meaning and use in the javac tool:
\begin{itemize}\nospace
\item -Akey
\item -J
\item -X
\item -implicit
\item -bootclasspath
\item -deprecation
\item -encoding
\item -endorsedirs
\item -extdirs
\item -g
\end{itemize}
 

\textit{This section will be completed later.} %% TBD



\chapter{The Eclipse Plug-in}

Since OpenJML operates on Java files, it is natural that it be integrated into the Eclipse IDE.
There is a conventional Eclipse plug-in that encapsulates the OpenJML command-line tool and integrates it
with the Eclipse Java development environment.

\section{Installation and System Requirements}
Your system must have the following:
\begin{itemize}
\item A Java 1.7 JRE as described in section \ref{Running} (there is no 1.6 work-around for the plug-in). This must be the JRE in use in the environment in which Eclipse is invoked. If you start Eclipse by a command in a shell, it is straightforward to make sure that the correct Java JRE is defined in that shell.  However, if you start Eclipse by, for example, double-clicking a desktop icon, then you must ensure that the Java 1.7 JRE is set by the system at startup.
\item Eclipse 3.6 or later
\end{itemize}

Installation of the plug-in follows the conventional Eclipse procedure.
\begin{itemize}
\item Invoke the "Install New Software" dialog under the Eclipse "Help" menubar item.
\item "Add" a new location, giving the URL \url{http://jmlspecs.sourceforge.net/openjml-updatesite} and some name of your choice (e.g. OpenJML).
\item Select the "OpenJML" category and push "Next"
\item Proceed through the rest of the wizard dialogs to install OpenJML.
\item Restart Eclipse when asked to obtain full functionality.
\end{itemize}

If the plug-in is successfully installed, a yellow coffee cup (the JML icon) will appear in the menubar (along with other menubar items).
The installation will fail (without obvious error messages), if the underlying Java VM is not a suitable Java 1.7 VM.

\section{GUI Features}

\textit{This section will be added later.} %% TBD


\chapter{OpenJML tools}

\section{Parsing and Type-checking}
\textit{This section will be added later.} %% TBD

\section{Static Checking and Verification}
\textit{This section will be added later.} %% TBD

\section{Runtime Assertion Checking}
\textit{This section will be added later.} %% TBD

\section{Generating Documentation}
\textit{This section will be added later.} %% TBD

\section{Generating Specification File Skeletons}
\textit{This section will be added later.} %% TBD

\section{Generating Test Cases}
\textit{This section will be added later.} %% TBD

\chapter{Using OpenJML and OpenJDK within user programs}

The OpenJML software is available as a library so that Java and JML programs can be manipulated 
within a user's program. The developer needs only to include the {\tt openjml.jar} library on 
the classpath when compiling a program and to call methods through the public API as described in this chapter.
The public API is implemented in the interface {\tt org.jmlspecs.openjml.IAPI}; it provides the ability to
\begin{itemize}
\item perform compilation actions as would be executed on the command-line
\item parse files or Strings containing Java and JML source code, producing parse trees
\item print parse trees
\item walk over parse trees to perform user-defined actions
\item type-check parse trees (both Java and JML checking)
\item perform static checking
\item compile modules with run-time checks
\item emit javadoc documentation with JML annotations
\end{itemize}
The sections of this chapter describe these actions and various concepts needed to perform them correctly.

CAUTION: OpenJML relies on parts of the OpenJDK software that are labeled as internal, non-public and subject to
change. Correspondingly, some of the OpenJML API may change in the future. The definition of the API class is 
intended to provide a buffer against such changes. However, the names and functionality of OpenJDK classes (e.g.,
the {\tt Context} class in the next section) could change.

\paragraph{List classes}
CAUTION \#2: The OpenJDK software uses its own implementation of Lists, namely {\tt com.sun.tools.javac.util.List}. 
It is a different implementation than {\tt java.util.List}, with a different interface. Since one or the other may
 be in the list of imports, the use of {\tt List} in the code may not clearly indicate which type of List is being
 used. Error messages are not always helpful here. Users should keep these two types of List in mind to avoid 
 confusion.

\paragraph{Example source code}
The subsections that follow contain many source code examples. 
Small source code snippets are shown in in-line boxes like this:
\boxedexample{ // A Java comment }
Larger examples are shown as full programs. These are followed by a box of text with a gray background that contains the output expected if the program is run (if the program is error-free) or compiled (if there are compilation errors).
Here is a ``Hello, world'' example program:
\demo{DemoHelloWorld}

\noindent
All of these full-program example programs are working, tested examples.
They are available in the {\tt demos} directory of the OpenJML source code. The opening comment
line (as well as the class name) of the example text gives the file name.

The full programs presume an appropriate environment. In particular, they expect the following
\begin{itemize}
\item the current working directory is the {\tt demos} directory of the OpenJML source distribution
\item the Java {\tt CLASSPATH} contains the current directory and a release version of the
OpenJML library ({\tt openjml.jar}). For example, if a copy of {\tt openjml.jar} is in the 
{\tt demos} directory, then the {\tt CLASSPATH} could be set as {\tt ``.;openjml.jar''} (using the ; on Windows, a : on Mac and Linux)
\end{itemize}
Note that the examples often use other files that are in subdirectories of the {\tt demos} directory.
\boxedexampleZ{
// bash commands to compile and run the DemoHelloWorld example
\begin{tabular}{ll}
cd OpenJML/demos     &\# Alter this to match your local installation \\
export CLASSPATH=''.;openjml.jar''     &\# Use a : instead of ; on Unix or Mac \\
                                       &\# Copy openjml.jar to the demo directory \\
javac DemoHelloWorld.java              &\# Be sure java tools from a 1.7 JDK  \\
java DemoHelloWorld                    &\# are on the PATH
\end{tabular}
}

\section{Concepts}

\subsection{Compilation Contexts}
All parsing and compilation activities within OpenJML are performed with respect to a {\em compilation context},
implemented in the code as a {\tt com.sun.tools.javac.util.Context}. There can be more than one Context at a given time,
though this is rare. A context holds all of the symbol tables and cached values that constitute the source code created
in that context. 

There is little need for the user to create or manipulate
Contexts. However it is essential items created in one Context not be used in another context. There is no check for such misuse, but the subsequent actions are likely to fail. For example, a Context contains interned versions of the names of
source code identifiers (as {\tt Name}s). Consequently an identifier parsed in one Context will 
appear different than an identifier
parsed in another Context, even if they have the same textual name. Do not try to reuse parse trees or other objects 
created in one Context in another Context.
 
Each instance of the {\tt IAPI} interface creates its own Context object and most methods on 
that {\tt IAPI} instance operate with respect to that Context. The {\tt API.close} operation 
releases the Context object, allowing the garbage collector to reclaim space.
\footnote{The OpenJDK software was designed as a command-line tool, in which all memory is reclaimed
when the process exits. Although in principle memory can be garbage collected when no more references
to a Context or its consitutent parts exist, the degree to which this is the case has not been tested.}

\label{JavaFileObjects}
\subsection{JavaFileObjects}

OpenJDK works with source files using {\tt JavaFileObject} objects. This class abstracts the behavior of 
ordinary source files. Recall that the definition of the Java language allows source material to be held 
in containers other than ordinary files on disk; The {\tt JavaFileObject} class accommodates such implementations.

OpenJML currently handles source material in ordinary files and source material expressed as {\tt String} objects
and contained in mock-file objects. Such mock objects make it easier to create source material progrmamatically, 
without having to create temporary files on disk.

Although the basic input unit to OpenJDK and OpenJML is a JavaFileObject, for convenience, methods that require
source material as input have variations allowing the inputs to be expressed as names of files or {\tt File} objects.
If needed, the following methods create JavaFileObjects:
\boxedexampleA{
String filename = ...
File file = new java.io.File(filename);
IAPI m = Factory.makeAPI();
JavaFileObject jfo1 = m.makeJFOfromFilename(filename);
JavaFileObject jfo2 = m.makeJFOfromFile(file);
JavaFileObject jfo3 = m.makeJFOfromString(filename,contents);
}
The last of the methods above, {\tt makeJFOfromString}, creates a mock-file object with the given contents (a String).
The {\tt contents} argument is a String holding the text that would be in a compilation unit.
The mock-object must have a sensible filename as well. In particular, the given filename should match the package and
class name as given in the {\tt contents} argument. In addition to creating the {\tt JavaFileObject} object, the 
mock-file is also added to an internal database of source mock-files; if a mock-file has a filename that would be on
the source path (were it a concrete file), then the mock-file is used as if it were a real file in an OpenJML compilation.
[TODO: Test this. Also, how to remove such files from the internal database. ] 

\subsection{Interfaces and concrete classes}

A design meant to be extended should preferably be expressed as Java interfaces; if client code uses the interface and not the underlying concrete classes, then reimplementing functionality with new classes is straightforward. The OpenJDK 
architecture uses interfaces in some places, but often it is the concrete classes that must be extended.

Table \ref{Interfaces} lists important interfaces, the corresponding OpenJDK concrete class, and the OpenJML replacement.

\begin{table}
\begin{tabular}{|l|l|l|}
\hline
Interface & OpenJDK class & OpenJML class \\ \hline
IAPI &  & API \\ \hline
 & com.sun.tools.javac.main.Main & org.jmlspecs.openjml.Main \\ \hline
 & Option & \\ \hline
IOption & & JmlOption \\ \hline
IVisitor & & \\ \hline
IJmlTree & & \\ \hline
IJmlVisitor & & \\ \hline
IProver & & \\ \hline
IProverResult & & ProverResult \\ \hline
IProverResult.ICounterexample & & Counterexample \\ \hline
IProverResult.ICoreIds & & \\ \hline
JCDiagnostic.DiagnosticPosition & SimpleDiagnosticPosition & DiagnosticPositionSE, DiagnosticPositionSES \\ \hline
Diagnostic<T> & JCDiagnostic & \\ \hline
 & com.sun.tools.javac.main.JavaCompiler & JmlCompiler \\ \hline
 & & \\ \hline
 & & \\ \hline
\end{tabular}
\caption{Interfaces and Classes}
\label{Interfaces}
\end{table}

TODO: Add Parser, Scanner, other tools, JCTree nodes, JMLTree nodes, Option/JmlOption, DiagnosticPosition, Tool, OptionCHecker


\subsection{Object Factories}

\subsection{Abstract Syntax Trees}

\subsection{Compilation Phases and The tool registry}

Compilation in the OpenJDK compiler proceeds in a number of phases. Each phase is implemented by a specific tool.
OpenJDK examples are the {\tt DocCommentScanner}, {\tt EndPosParser}, {\tt Flow}, performing scanning, parsing and flow checks respectively; the OpenJML counterparts are {\tt JmlScanner}, {\tt JmlParser}, and {\tt JmlFlow}.

In each compilation context there is one instance of each tool, registered with the context. The Context contains a map
of keys to the singleton instance of the tool (or its factory) for that context. The scanner and parser are treated slightly differently: there is a singleton instance of a scanner factory and a parser factory, but a new instance of the
scanner and the parser are created for each compilation unit compiled. Tables \ref{Tools1} and \ref{Tools2} list the tools
most likely to be encounterded when programming with OpenJML.

OpenJML implements
alternate versions of many of the OpenJDK tools. The OpenJML versions are derived from the OpenJDK versions and are 
registered in the context in place of the OpenJDK versions. In that way, anywhere in the software that a tool is
obtained (using the syntax {\tt ZZZ.instance(context)} for a tool {\tt ZZZ}), the appropriate version and instance
of the tool
is produced.

In some cases, a {\em tool factory} is registered instead of a tool instance. Then a tool instance is created on the
first request for an instance of the tool. The reason for this is the following. Most tools use other tools and, for
efficiency, request instances of those tools in their constructors. Circular dependencies can easily arise among these
tool dependencies. Using factories helps mitigate this, though the problem still does easily arise.



\begin{table}
\begin{tabularx}{\textwidth}{|p{1.5in}|p{1.5in}|X|}

\hline
Purpose & Java and JML tool &  Notes \\
\hline
overall compiler & JavaCompiler, JmlCompiler & controls the flow of compilation phases \\
\hline
scanner factory & ScannerFactory, JmlScanner.Factory  & \\
\hline
Token scanning & DocCommentScanner, JmlScanner &  new instance created from the factory for each compilation unit \\
\hline
parser factory & ParserFactory, JmlFactory  & \\
\hline
parser & EndPosParser, JmlParser & new instance created from the factory for each compilation unit \\
\hline
symbol table construction & Enter, JmlEnter & \\
\hline
annotation processing & Annotate & performed in JavaCompiler.processAnnotations\\
\hline
type determination and checking & Attr, JmlAttr & \\
\hline
flow-sensitive checks & Flow, JmlFlow & simple type-checking stops here \\
\hline
\hline
static checking & JmlEsc & invoked instead of desugaring if static checking is enabled (and processing ends here) \\
\hline
\hline
runtime assertion checking & JmlRac & invoked if RAC is enabled, and then proceeds with the remainder of compilation and code generation \\
\hline
desugaring generics & & performed in the method JavaCompiler.desugar \\
\hline
code generation & Gen & not used for ESC \\
\hline


\end{tabularx}
\caption{Compilation phases and corresponding tools as implemented in JavaCompiler and JmlCompiler}
\label{Tools1}
\end{table}

\begin{table}[bth]
\begin{center}
\begin{tabular}{|l|l|l|}

\hline
Purpose & Java and JML tool &  Notes \\
\hline
identifier table & Names & \\
\hline
symbol table & SymTab & \\
\hline
compiler and command-line options & Options, JmlOptions & \\
\hline
AST node factory & JCTree.Factory, JmlTree.Maker & \\
\hline
message reporting & Log & \\
\hline
printing ASTs & Pretty, JmlPretty & \\
\hline
name resolution & Resolve, JmlResolver & \\
\hline
AST utilities & TreeInfo, JmlTreeInfo & \\
\hline
type checks & Check, JmlCheck & \\
hline
creating diagnostic message objects & JCDiagnostic.Factory & \\
\hline
\end{tabular}
\end{center}
\caption{Some of the other registered tools}
\label{Tools2}
\end{table}

TBD: Others - MemberEnter, JmlMemberEnter, JmlRac, JmlCheck, Infer, Types, Options, Lint, Source, JavacMessages, DiagnosticListener, JavaFileManager/JavacFileManager, ClassReader/javadocClassReader, JavadocEnter, DocEnv/DocEnvJml, BasicBlocker, ProgressReporter?, ClassReader, ClassWriter, Todo, Annotate, Types, TaskListener, JavacTaskImpl, JavacTrees

TBD: Others - JmlSpecs, Utils, Nowarns, JmlTranslator, Dependencies

TBD: Is JmlTreeInfo still used

\section{OpenJML operations}

\subsection{Methods equivalent to command-line operations}

The {\tt execute} methods of {\tt IAPI} perform the same operation as a command on the command-line.
These methods are different than others of {\tt IAPI} in that they create and use their own {\tt Context}
object, ignoring that of the calling {\tt IAPI} object.

The simple method is shown here:
\boxedexampleA{
import org.jmlspecs.openjml.IAPI;

IAPI m = new org.jmlspecs.openjml.API();
int returnCode = m.execute(``-check'',''-noPurityCheck'',''src/demo/Err.java'');
}
\noindent
Each argument that would appear on the command-line is a separate argument to {\tt execute}.
All informational and diagnostic output is sent to {\tt System.out}.
The value returned by {\tt execute} is the same as the exit code returned by the equivalent command-line operation.
The String arguments are a varargs list, so they can be provided to {\tt execute} as a single array:
\boxedexampleA{
import org.jmlspecs.openjml.IAPI;

String[] args = new String[]{``-check'',''-noPurityCheck'',''src/demo/Err.java''}
IAPI m = new org.jmlspecs.openjml.API();
int returnCode = m.execute(args);
}
\noindent
A full example of using execute is shown below:
\boxedinputc{\source/DemoExecute.java}{\source/DemoExecute.txt}

\noindent
A longer form of {\tt execute} takes two additional arguments: a {\tt Writer} and a
{\tt DiagnosticListener}. The {\tt Writer} receives all the informational output.
The {\tt report} method of the {\tt DiagnosticListener} is called for each warning or
error diagnostic generated by OpenJML. Here is a full example of this method:
\demo{DemoExecute2}


\subsection{Parsing}

There are two varieties of parsing. The first parses an individual Java or specification file, producing an AST that
represents that source file. The second parses both a Java file and its specification file, if there is a separate one.
The second form is generally more useful, since the specification file is found automatically. However, if the parse trees
are being constructed programmatically, it may be useful to parse the files individually and then manually associate them.

Parsing constructs a parse tree. No symbols are created or entered into a symbol table. Nor is any type-checking performed.
The only global effect is that identifiers are interned in the {\tt Names} table, which is specific to the compilation context.
Thus the only effect of discarding a parse tree is that there may be orphaned (no longer used) names in the {\tt Names} table.
The {\tt Names} table cannot be cleared without the risk of dangling identifiers in parse trees.

Other than this consideration, parse trees can be created, manipulated, edited and discarded. Section TBD describes tools for
manually creating parse trees and walking over them. Once a parse tree is type-checked, it should be considered immutable.

\subsubsection{Parsing individual files}

There are two methods for parsing an individual file. The basic 
method takes a {\tt JavaFileObject} as input and produces an AST.
The convenience method takes a filename as input and produces an AST. The methods of section \ref{JavaFileObjects} enable you to
produce {\tt JavaFileObject}s from filenames, File objects, or Strings that hold the equivalent of the contents of a file (a compilation unit).
\boxedexampleA{
JmlCompilationUnit parseSingleFile(String filename);\\
JmlCompilationUnit parseSingleFile(JavaFileObject jfo);
}
The filename is relative to the current working directory.
%% TBD: Change to reflect interfaces; check the JFO signature

Here is a full example that shows both interfaces and shows how to attach a specification parse tree to its Java parse tree.
\demo{DemoParseSingle}


%% TBD: How to attach specs to binary class files?

\subsubsection{Parsing Java and JML files together}

The more common action is to parse a Java file and its specification at the same time. The JML language defines how the specification file is found for a given source or binary class. In short, the specification file has syntax very similar to 
a Java file:
\begin{itemize}
\item it must be in the same package and have the same class name as the Java class
\item if both are files, the filenames without suffix must be the same
\item the specification file must be on the {\em specspath}
\item if a .jml file meeting the above criteria is found anywhere on the specspath, it is used; otherwise a .java file meeting
the above criteria is used; otherwise only default specifications are used.\footnote{In the past, JML allowed multiple specification files and defined an ordering and rules for combining the specifications contained in them. The JML has been 
simplified to allow just one specification file, just one suffix (.jml), and no combining of specifications from a .jml and a .java file if both exist.}
\end{itemize}
Note that a Java file can be specified on the command-line that is not on the specspath. In that case (if there is no .jml file) 
not specification file will be found, although the user may expect that the Java file itself may serve as its own specifications.
This is a confusing situation and should be avoided.

%% TBD - more needed

\subsection{Type-checking}

\subsection{Static checking}

\subsection{Compiling run-time checks}

\subsection{Creating JML-enhanced documentation}

\section{Working with ASTs}

\subsection{Printing parse trees}

TBD

\subsection{Source location information}

TBD

\subsection{Exploring parse trees with Visitors}
OpenJML defines some Visitor classes that can be extended to implement user-defined functionality while traversing a parse tree.
The basic class is {\tt JmlScanner}. An unmodified instance of {\tt JmlScanner} will traverse a parse tree without performing
any actions.

There are three modes of traversing an AST.
\begin{itemize}
\item AST\_JAVA\_MODE - traverses only the Java portion of an AST, ignoring any JML annotations
\item AST\_JML\_MODE - traverses the Java and JML syntax that was part of the original source file
\item AST\_SPEC\_MODE - traverses the Java syntax and its specifications (whether they came from the same source file or a different one). This mode is only available after the AST has been type-checked.
\end{itemize}

A derived class can affect the behavior of the visitor in two ways:
\begin{itemize}
\item By overriding the {\tt scan} method, an action can be performed at every node of an AST
\item By overriding specific {\tt visit...} methods, an action can be performed only at the nodes of the corresponding type
\end{itemize}

In the example that follows, the scan method of the Visitor is modified to count all nodes in the AST, the visitBinary method
is modified to count Java binary operations, and the visitJmlBinary method is modified to count JML binary operations.
The default constructor of the parent Visitor class sets the traversal mode to AST\_JML\_MODE.
\demo{DemoWalkTree1}

The second example shows the differences among the three traversal modes. Note that the AST\_SPEC\_MODE traversal fails when requested prior to type-checking the AST.
\demo{DemoWalkTree2}

There are two other points to make about these examples.
\begin{itemize}
\item Note that each derived method calls the superclass version of the method that it overrides. The superclass method implements the logic to traverse all the children of the AST node. If the super call is omitted, no traversal of the children is performed. If the derived class wishes to traverse only some of the children, a specialized implementation of the method will need to be created.
It is easiest to create such an implementation by consulting the code in the super class.
\item In the examples above, you can see that the System.out.println statement that prints the node's class occurs before the super call. The result is a pre-order traversal of the tree; if the print statement occurred after the super call, the output would show a post-order traversal.
\end{itemize}

%% TBD - comment on other visitor classes

\subsection{Creating parse trees}

\section{Working with JML specifications}

\section{Utilities}

-- version
-- context
-- symbols

\section{Extending or modifying JML}
JML is modified by providing new implementations of key classes, typically by derivation from those that are part of OpenJML.
In fact, OpenJML extends many of the OpenJDK classes to incorporate JML functionality into the OpenJDK Java compiler.

\subsection{Adding new command-line options}
\subsection{Altering IAPI}
\subsection{Changing the Scanner}
\subsection{Enhancing the parser}
\subsection{Adding new modifiers and annotations}
\subsection{Adding new AST nodes}
\subsection{Modifying a compiler phase}
\part{JML}

The definition of the Java Modeling Language is given in the JML Reference Manual\cite{TBD}.
This document does not repeat that definition in detail. However, it is 
\chapter{Summary of JML Features}

The definition of the Java Modeling Language is contained in the reference manual.\cite{TBD}
That definition will not be repeated here.  However, the following sections contain
comments about JML as they relate to the implementation within OpenJML.

\section{JML Syntax}

\subsection{Syntax of JML specifications}

JML specifications are contained in specially formatted Java comments:
a JML specification includes everything between either (a) an opening {\tt /*\at} and closing {\tt */}
or (b) an opening {\tt //\at} and the next line ending character ({\tt \bs n}
or {\tt \bs r}) that is not within a string or character literal.

Such comments that occur within the body of a class or interface definition are
considered to be a specification of the class, a field, or a method, depending on the
kind of specification clause it is. JML specifications may also occur in the body of 
a method.

\paragraph{Obsolete syntax.} In previous versions of JML, JML specifications could be placed
within javadoc comments. Such specifications are no longer standard JML and are not supported by OpenJML.

\subsection{Conditional JML specifications}

JML has a mechanism for conditional specifications, based on a system of keys.
A key is a Java identifier (alphanumerics, including the underscore character, and beginning with a non-digit).
A conditional JML comment is guarded by one or more positive or negative keys (or both).
The keys are placed just before the \at~character that is part of the opening sequence of the JML comment
(the {\tt //\at} or the {\tt /*\at}). Each key is preceded by a '+' or a '-' sign, to indicate whether it is a positive
or negative key, respectively. {\it No white-space is allowed}. If there is white-space anywhere between the
initial {\tt //} or {\tt /*} and the first \at~character, the comment will appear to be a normal Java comment and will be
silently ignored.

The keys are interpreted as follows. Each tool that processes the Java+JML input will have a means
(e.g. by command-line options) to specify the set of keys that are enabled.
\begin{itemize}
\item If the JML annotation has no keys, the annotation is always processed.
\item If there are only positive keys, the annotation is processed only if at least one of the keys is enabled.
\item If there are only negative keys, the annotation is processed unless one of the keys is enabled.
\item If there are both positive and negative keys, the annotation is processed only if (a) at least one of the
positive keys is enabled AND (b) none of the negative keys are enabled.
\end{itemize}

JML previously defined one conditional annotation: those that began with {\tt /*+\at} or {\tt //+\at}. ESC/Java2 also defined
{\tt /*-\at} and {\tt //-\at}. Both of these are now deprecated. OpenJML does have an option to enable the +-style comments.

The particular keys do not have any defined meaning. OpenJML implicitly enables the ESC key when it is performing
ESC static checking; it implicitly enables the RAC key when it is performing Runtime-Assertion-Checking. Thus, for
example, one can turn off a non-executable assert statement for RAC-processing by writing //-RAC@ assert ... 


\subsection{Finding specification files and the refine statement}

JML allows specifications to be placed directly in the .java files that contain the implementation of methods and
classes. Indeed, specifications such as assert statements or loop invariants are necessarily placed directly in
a method body. Other specifications, such as class invariants and method pre- and post-conditions, may be placed in
auxiliary files. For classes which are only present as .class files and not as .java files, the auxiliary file is
a necessity.

Current JML allows one such auxiliary file. It is similar to the corresponding .java file except that
\begin{itemize} \nospace
\item it has a .jml suffix
\item it contains no method bodies (method declarations are terminated with semi-colons, as if they were abstract)
\end{itemize}
The .jml file is in the same package as the corresponding .java file and has the same name, except for the suffix.
If there is no source file, then there is a .jml file for each class that has a specification. [ TBD - what about non public classes]
 
\textit{This section will be added later.} %% TBD

\paragraph{Obsolete syntax.} The {\tt refine} and {\tt refines} statements are no longer recognized.
The previous (complicated) method of finding specification files and merging the specifications
from multiple files is also no longer implemented. The only specification file suffix allowed is 
{\tt .jml}; the others --- {\tt .spec}, {\tt .refines-java}, {\tt .refines-spec}, {\tt .refines-jml} --- 
are no longer implemented.

In addition, the {\tt .jml} file is sought before seeking the {\tt .java} file; if a {\tt .jml}
file is found anywhere in the specs path, then any specifications in the {\tt .java} file are 
ignored. This is a different search algorithm than was previously used.

\subsection{JML specifications and Java annotations}
\textit{This section will be added later.} %% TBD

\subsection{Model import statements}
\textit{This section will be added later.} %% TBD

\subsection{Modifiers}
\textit{This section will be added later.} %% TBD

- note elimination of weakly

\subsection{Method specification clauses}
\textit{This section will be added later.} %% TBD

\subsection{Class specification clauses}
\textit{This section will be added later.} %% TBD

\subsection{Visibility of specifications}
\textit{This section will be added later.} %% TBD

\subsection{Statement specifications}
\textit{This section will be added later.} %% TBD

\subsection{Refining statement specifications}
\textit{This section will be added later.} %% TBD

\subsection{JML expressions}
\textit{This section will be added later.} %% TBD

\subsection{JML operators}
\textit{This section will be added later.} %% TBD

\subsection{JML types}
\textit{This section will be added later.} %% TBD

\subsection{JML informal comments}
\textit{This section will be added later.} %% TBD

\subsection{Non-Null and Nullable}
\textit{This section will be added later.} %% TBD

\subsection{Race condition detection}
\textit{This section will be added later.} %% TBD

\subsection{Arithmetic modes}
\textit{This section will be added later.} %% TBD

\subsection{Universe types}
\textit{This section will be added later.} %% TBD

\subsection{Dynamic frames}
\textit{This section will be added later.} %% TBD

\subsection{Code contracts}
\textit{This section will be added later.} %% TBD

\subsection{redundantly suffixes}
\textit{This section will be added later.} %% TBD

\subsection{nowarn lexical construct}

\textit{This section will be added later.} %% TBD


\section{Interaction with Java features}

\textit{This section will be added later.} %% TBD


\section{Other issues}

\subsection{Interaction with JSR-308}
\textit{This section will be added later.} %% TBD

\textit{This section will be added later.} %% TBD


\subsection{Interaction with FindBugs}

\textit{This section will be added later.} %% TBD

\part{Semantics and translation of Java and JML in OpenJML}

\chapter{Introduction}

-- Sorted First-order-logic

-- individual subexpressions; optional expression form; optimization; usefulness for tracing

-- RAC vs. ESC

-- nomenclature



\chapter{Statement translations}

TODO: Need to insert both RAC and ESC in all of the following.

\section{While loop}

\noindent
Java and JML statement:

\noindent
{\tt }\\
{\tt //@ invariant} {\em\bf invariant\_condition} {\tt ;}\\
{\tt //@ decreases} {\em\bf counter} {\tt ;}\\
{\tt while (}{\em\bf condition) }{\tt \{}\\
\ind{\tt }{\em\bf body}\\
{\tt \}}\\

\noindent
Translation: {\em TODO: Needs variant condition, havoc information}

\noindent
{\tt }\\
{\tt \{}\\
\ind {\tt //@ assert }{\em jmltranslate({\bf invariant\_condition})} {\tt ;}\\
\ind {\tt //@ assert }{\em jmltranslate({\bf variant\_condition}) }{\tt > 0} {\tt ;}\\
\ind {\tt while (true) \{}\\
\ind\ind {\em stats(tmp,{\bf condition})}\\
\ind\ind {\tt if (!}{\em tmp}{) \{}\\
\ind\ind\ind {\tt //@ assume !}{\em tmp}{\tt ;}\\
\ind\ind\ind {\tt break;}\\
\ind\ind {\tt \}}\\
\ind\ind{\tt //@ assume }{\em tmp}{\tt ;}\\
\ind\ind {\tt }{\em stats({\bf body})}\\
\ind {\tt \} }\\
{\tt \}}

\chapter{Java expression translations}

\section{Implicit or explicit arithmetic conversions}

{\em TODO}

\section{Arithmetic expressions}
{\em TODO: need arithmetic range assertions}

In these, {\em T} is the type of the result of the operation. The two operands in binary operations are already assumed to have been converted to a common type according to Java's rules.

\noindent
{\em stats(tmp, }{\tt -} {\bf a} {\em )} ==> \\
\ind {\em stats(tmpa, }{\bf a} {\em )} \\
\ind {\em T tmp} {\tt =} {\tt - }{\em tmpa} {\tt ;} \\

\noindent
{\em stats(tmp, }{\bf a} {\tt +} {\bf b} {\em )} ==> \\
\ind {\em stats(tmpa, }{\bf a} {\em )} \\
\ind {\em stats(tmpb, }{\bf b} {\em )} \\
\ind {\em T tmp} {\tt =} {\em tmpa} {\tt +} {\em tmpb} {\tt ;} \\

\noindent
{\em stats(tmp, }{\bf a} {\tt -} {\bf b} {\em )} ==> \\
\ind {\em stats(tmpa, }{\bf a} {\em )} \\
\ind {\em stats(tmpb, }{\bf b} {\em )} \\
\ind {\em T tmp} {\tt =} {\em tmpa} {\tt -} {\em tmpb} {\tt ;}\\

\noindent
{\em stats(tmp, }{\bf a} {\tt *} {\bf b} {\em )} ==> \\
\ind {\em stats(tmpa, }{\bf a} {\em )} \\
\ind {\em stats(tmpb, }{\bf b} {\em )} \\
\ind {\em T tmp} {\tt =} {\em tmpa} {\tt *} {\em tmpb} {\tt ;}\\

\noindent
{\em stats(tmp, }{\bf a} {\tt /} {\bf b} {\em )} ==> \\
\ind {\em stats(tmpa, }{\bf a} {\em )} \\
\ind {\em stats(tmpb, }{\bf b} {\em )} \\
\ind {\tt //@ assert} {\em tmpb} {\tt != 0;} {\em // No division by zero}\\
\ind {\em T tmp} {\tt =} {\em tmpa} {\tt /} {\em tmpb} {\tt ;}\\

\noindent
{\em stats(tmp, }{\bf a} {\tt \%} {\bf b} {\em )} ==> \\
\ind {\em stats(tmpa, }{\bf a} {\em )} \\
\ind {\em stats(tmpb, }{\bf b} {\em )} \\
\ind {\tt //@ assert} {\em tmpb} {\tt != 0;} {\em // No division by zero}\\
\ind {\em T tmp} {\tt =} {\em tmpa} {\tt \%} {\em tmpb} {\tt ;}\\

\section{Bit-shift expressions}

{\em TODO}

\section{Relational expressions}

\noindent
No assertions are generated for the relational operations {\tt < > <= >= == !=}. The operands are presumed to have been converted to a common type according to Java's rules.\\

\noindent
{\em stats(tmp, }{\bf a} {\em op} {\bf b} {\em )} ==> \\
\ind {\em stats(tmpa, }{\bf a} {\em )} \\
\ind {\em stats(tmpb, }{\bf b} {\em )} \\
\ind {\em T tmp} {\tt =} {\em tmpa} {\em op} {\em tmpb} {\tt ;}\\

\section{Logical expressions}

\noindent
{\em stats(tmp,} {\tt !} {\bf a} {\em )} ==> \\
\ind {\em stats(tmpa, }{\bf a} {\em )} \\
\ind {\em T tmp} {\tt =} {\tt !} {\em tmpa} {\tt ;}\\

\noindent
The {\tt \&\&} and {\tt ||} operations are short-circuit operations in which the second operand is conditionally evaluated.
Here {\tt \&} and {\tt |} are the (FOL) boolean non-short-circuit conjunction and disjunction.\\

\noindent
{\em stats(tmp, }{\bf a} {\tt \&\&} {\bf b} {\em )} ==> \\
\ind {\tt boolean } {\em tmp} {\tt ;} \\
\ind {\em stats(tmpa, }{\bf a} {\em )} \\
\ind {\tt if (} {\em tmpa} {\tt ) \{} \\
\ind\ind {\tt //@ assume} {\em tmpa} {\tt ;} \\
\ind\ind {\em stats(tmpb, }{\bf b} {\em )} \\
\ind\ind {\em tmp} {\tt =} {\em tmpa} {\tt \&} {\em tmpb} {\tt ;}\\
\ind {\tt \} else \{}\\
\ind\ind {\tt //@ assume !} {\em tmpa} {\tt ;} \\
\ind\ind {\em tmp} {\tt =} {\em tmpa} {\tt ;}\\
\ind {\tt \}}\\

\noindent
{\em stats(tmp, }{\bf a} {\tt ||} {\bf b} {\em )} ==> \\
\ind {\tt boolean } {\em tmp} {\tt ;} \\
\ind {\em stats(tmpa, }{\bf a} {\em )} \\
\ind {\tt if ( !} {\em tmpa} {\tt ) \{} \\
\ind\ind {\tt //@ assume !} {\em tmpa} {\tt ;} \\
\ind\ind {\em stats(tmpb, }{\bf b} {\em )} \\
\ind\ind {\em tmp} {\tt =} {\em tmpa} {\tt |} {\em tmpb} {\tt ;}\\
\ind {\tt \} else \{}\\
\ind\ind {\tt //@ assume} {\em tmpa} {\tt ;} \\
\ind\ind {\em tmp} {\tt =} {\em tmpa} {\tt ;}\\
\ind {\tt \}}\\

\pagebreak

\textit{An index will be added later.} %% TBD


%% TBD - index
%% TBD - bibliography

@end ifset

@bye
